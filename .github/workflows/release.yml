name: Build and Release

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:

jobs:
  build:
    runs-on: ${{ matrix.os }}

    strategy:
      matrix:
        include:
          - os: macos-latest
            platform: mac
            arch: x64
            goos: darwin
            goarch: amd64
            ext: dmg
          - os: macos-latest
            platform: mac
            arch: arm64
            goos: darwin
            goarch: arm64
            ext: dmg
          - os: windows-latest
            platform: win
            arch: x64
            goos: windows
            goarch: amd64
            ext: exe
          - os: ubuntu-latest
            platform: linux
            arch: x64
            goos: linux
            goarch: amd64
            ext: AppImage

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.21'

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: npm

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable

      - name: Cache Rust dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            src-tauri/target/
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Build Go binaries
        shell: bash
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
          CGO_ENABLED: ${{ matrix.goos == 'windows' && '0' || '1' }}
        run: |
          mkdir -p bin
          go build -ldflags="-s -w" -trimpath -o bin/api-wrapper${{ matrix.goos == 'windows' && '.exe' || '' }} ./cmd/api-wrapper
          go build -ldflags="-s -w" -trimpath -o bin/clidm${{ matrix.goos == 'windows' && '.exe' || '' }} ./cmd/clidm
          # Strip binaries on Unix-like systems to further reduce size
          if [ "${{ matrix.goos }}" != "windows" ]; then
            if command -v strip &> /dev/null; then
              echo "Stripping binaries..."
              strip bin/api-wrapper${{ matrix.goos == 'windows' && '.exe' || '' }} 2>/dev/null || echo "strip failed, continuing..."
              strip bin/clidm${{ matrix.goos == 'windows' && '.exe' || '' }} 2>/dev/null || echo "strip failed, continuing..."
              echo "✓ Binaries optimized"
            else
              echo "⚠ strip not available, skipping"
            fi
          fi
          echo "Downloading Iris..."
          bash scripts/download-iris.sh || echo "Warning: Failed to download Iris"
          echo "Binary sizes:"
          ls -lh bin/ || true

      - name: Install Node Deps
        run: npm ci

      - name: Build Frontend
        run: npm run build:react

      - name: Verify Resources
        run: npm run verify:resources

      - name: Install Linux build dependencies
        if: matrix.platform == 'linux'
        shell: bash
        run: |
          # Install unsquashfs for AppImage extraction (if not available)
          if ! command -v unsquashfs &> /dev/null; then
            echo "Installing squashfs-tools for AppImage extraction..."
            sudo apt-get update -qq && sudo apt-get install -y squashfs-tools 2>/dev/null || echo "⚠ Could not install squashfs-tools"
          fi
      
      - name: Verify build prerequisites
        if: matrix.platform == 'linux'
        shell: bash
        run: |
          echo "=== Verifying Linux build prerequisites ==="
          echo "Checking for icon file:"
          if [ ! -f "build/icon.png" ]; then
            echo "Warning: icon.png not found, attempting to create from icon.icns"
            # Try to convert from icns if available
            if command -v convert &> /dev/null; then
              # Linux: use ImageMagick to convert
              convert build/icon.icns build/icon.png 2>/dev/null && echo "✓ Converted icon.icns to icon.png" || echo "⚠ Conversion failed - electron-builder will use default icon"
            else
              echo "⚠ ImageMagick not available - installing for icon conversion"
              sudo apt-get update -qq && sudo apt-get install -y imagemagick 2>/dev/null || echo "⚠ Could not install ImageMagick"
              if command -v convert &> /dev/null; then
                convert build/icon.icns build/icon.png 2>/dev/null && echo "✓ Converted icon.icns to icon.png" || echo "⚠ Conversion failed"
              else
                echo "⚠ No conversion tool available, electron-builder will use default icon"
              fi
            fi
          else
            echo "✓ icon.png found"
            ls -la build/icon.png
          fi
          echo ""
          echo "Checking for Go binaries:"
          if [ -f "bin/api-wrapper" ] && [ -f "bin/clidm" ]; then
            echo "✓ Go binaries found"
            ls -lh bin/api-wrapper bin/clidm
            chmod +x bin/api-wrapper bin/clidm || true
          else
            echo "✗ ERROR: Go binaries not found!"
            ls -la bin/ || echo "bin/ directory does not exist"
            exit 1
          fi
          echo ""
          echo "Checking for dist directory:"
          if [ -d "dist" ]; then
            echo "✓ dist directory found"
            ls -la dist/ | head -5
          else
            echo "✗ ERROR: dist directory not found!"
            exit 1
          fi

      - name: Build Tauri App (macOS)
        if: matrix.platform == 'mac'
        shell: bash
        env:
          PATH: ${{ env.PATH }}:$HOME/.cargo/bin
        run: |
            echo "=== Building Tauri app ==="
            export PATH="$HOME/.cargo/bin:$PATH"
            
            # Build Tauri app (Tauri handles DMG creation automatically)
            if [ "${{ matrix.goarch }}" == "amd64" ]; then
              npx tauri build --bundles dmg --target x86_64-apple-darwin > build.log 2>&1 || (cat build.log && exit 1)
            else
              npx tauri build --bundles dmg --target aarch64-apple-darwin > build.log 2>&1 || (cat build.log && exit 1)
            fi
            
            # Find the DMG file
            DMG_PATH=$(find src-tauri/target/release/bundle/dmg -name "*.dmg" 2>/dev/null | head -1)
            
            if [ -z "$DMG_PATH" ]; then
              echo "✗ ERROR: DMG file not found!"
              echo "Searching in bundle directory:"
              find src-tauri/target/release/bundle -type f 2>/dev/null || echo "No files found"
              exit 1
            fi
            
            echo "✓ DMG created: $DMG_PATH"
            ls -lh "$DMG_PATH"
            
            # Copy to release directory with architecture naming
            mkdir -p release
            ARCH_DMG="release/ACCELARA-mac-${{ matrix.goarch }}.dmg"
            cp "$DMG_PATH" "$ARCH_DMG"
            echo "✓ Copied to: $ARCH_DMG"
            ls -lh "$ARCH_DMG"
            
            # Verify binaries in app bundle
            APP_BUNDLE=$(find src-tauri/target/release/bundle/macos -name "*.app" -type d 2>/dev/null | head -1)
            if [ -n "$APP_BUNDLE" ]; then
              echo "=== Verifying binaries in app bundle ==="
              BIN_PATH="$APP_BUNDLE/Contents/Resources/bin"
              if [ -d "$BIN_PATH" ]; then
                echo "✓ Bin directory found: $BIN_PATH"
                ls -lh "$BIN_PATH" || echo "Could not list bin directory"
                if [ -f "$BIN_PATH/api-wrapper" ] && [ -f "$BIN_PATH/iris" ]; then
                  echo "✓ All binaries verified"
                else
                  echo "⚠ Warning: Some binaries missing (Tauri should have bundled them)"
                fi
              else
                echo "⚠ Warning: Bin directory not found (Tauri should have created it)"
              fi
            fi
            
            echo "✓ macOS build completed successfully"

      - name: Build Tauri App (Windows)
        if: matrix.platform == 'win'
        shell: bash
        env:
          PATH: ${{ env.PATH }}:$HOME/.cargo/bin
        run: |
          echo "=== Building Windows installer ==="
          export PATH="$HOME/.cargo/bin:$PATH"
          npx tauri build --bundles msi --target x86_64-pc-windows-msvc > build.log 2>&1 || (cat build.log && exit 1)
          echo ""
          echo "=== Windows build output ==="
          if [ -d "src-tauri/target/release/bundle" ]; then
            find src-tauri/target/release/bundle -name "*.msi" -o -name "*.exe" -type f 2>/dev/null || echo "No installer files found"
            # Copy to release directory
            mkdir -p release
            find src-tauri/target/release/bundle -name "*.msi" -o -name "*.exe" -type f -exec cp {} release/ \;
          fi

      - name: Build Tauri App (Linux)
        if: matrix.platform == 'linux'
        shell: bash
        env:
          PATH: ${{ env.PATH }}:$HOME/.cargo/bin
        run: |
          export PATH="$HOME/.cargo/bin:$PATH"
          echo "=== Building Linux AppImage ==="
          
          # Verify prerequisites before building
          if [ ! -f "bin/api-wrapper" ]; then
            echo "✗ ERROR: api-wrapper binary not found!"
            exit 1
          fi
          if [ ! -d "dist" ]; then
            echo "✗ ERROR: dist directory not found!"
            exit 1
          fi
          
          # Build Tauri app (Tauri handles AppImage creation automatically)
          npx tauri build --bundles appimage --target x86_64-unknown-linux-gnu > build.log 2>&1 || (cat build.log && exit 1)
          
          # Find the AppImage file
          APPIMAGE=$(find src-tauri/target/release/bundle/appimage -name "*.AppImage" 2>/dev/null | head -1)
          
          if [ -z "$APPIMAGE" ]; then
            echo "✗ ERROR: AppImage file not found!"
            echo "Searching in bundle directory:"
            find src-tauri/target/release/bundle -type f 2>/dev/null || echo "No files found"
            exit 1
          fi
          
          echo "✓ AppImage created: $APPIMAGE"
          ls -lh "$APPIMAGE"
          
          # Copy to release directory
          mkdir -p release
          cp "$APPIMAGE" release/ACCELARA-linux-x64.AppImage
          echo "✓ Copied to: release/ACCELARA-linux-x64.AppImage"
          ls -lh release/ACCELARA-linux-x64.AppImage
          
          # Make executable
          chmod +x release/ACCELARA-linux-x64.AppImage
          echo "✓ Made AppImage executable"
          
          # Verify binaries in app bundle (if unpacked version exists)
          UNPACKED_DIR=$(find src-tauri/target/release -name "*unpacked" -type d 2>/dev/null | head -1)
          if [ -n "$UNPACKED_DIR" ]; then
            echo "=== Verifying binaries in unpacked directory ==="
            BIN_PATH="$UNPACKED_DIR/resources/bin"
            if [ -d "$BIN_PATH" ]; then
              echo "✓ Bin directory found: $BIN_PATH"
              ls -lh "$BIN_PATH" || echo "Could not list bin directory"
              if [ -f "$BIN_PATH/api-wrapper" ] && [ -f "$BIN_PATH/iris" ]; then
                echo "✓ All binaries verified"
              else
                echo "⚠ Warning: Some binaries missing (Tauri should have bundled them)"
              fi
            fi
          fi
          
          echo "✓ Linux build completed successfully"
      
      - name: List build outputs
        shell: bash
        run: |
          set +e  # Don't exit on error for this diagnostic step
          set +o pipefail  # Don't fail on pipe errors
          echo "=== Build Output Structure ==="
          if [ -d "release" ]; then
            echo "=== All DMG files ==="
            find release -name "*.dmg" -type f 2>/dev/null || echo "No DMG files found"
            echo ""
            echo "=== All APP bundles ==="
            find release -name "*.app" -type d 2>/dev/null || echo "No APP bundles found"
            echo ""
            echo "=== All files in release ==="
            (find release -type f 2>/dev/null | head -30) || echo "No files found"
            echo ""
            echo "=== Release directory structure ==="
            ls -la release/ 2>/dev/null || echo "release/ not found"
            if [ -d "release/mac" ]; then
              echo "=== release/mac contents ==="
              ls -la release/mac/ 2>/dev/null || true
            fi
            if [ -d "release/mac-arm64" ]; then
              echo "=== release/mac-arm64 contents ==="
              ls -la release/mac-arm64/ 2>/dev/null || true
            fi
            if [ -d "release/mac-x64" ]; then
              echo "=== release/mac-x64 contents ==="
              ls -la release/mac-x64/ 2>/dev/null || true
            fi
          else
            echo "release directory does not exist"
          fi
          exit 0  # Always succeed - this is a diagnostic step

      - name: Find build artifacts
        id: find-artifacts
        shell: bash
        run: |
          set +e  # Don't exit on error
          set +o pipefail  # Don't fail on pipe errors
          ARTIFACT=""
          APP_BUNDLE=""
          
          if [ "${{ matrix.platform }}" == "mac" ]; then
            # Try multiple possible locations
            if [ -d "release" ]; then
              # DMG is primary distribution format for macOS
              ARTIFACT=$(find release -name "ACCELARA-mac-${{ matrix.goarch }}.dmg" -type f 2>/dev/null | head -1 || true)
              if [ -z "$ARTIFACT" ]; then
                ARTIFACT=$(find release -name "ACCELARA*.dmg" -type f 2>/dev/null | head -1 || true)
              fi
              if [ -z "$ARTIFACT" ]; then
                ARTIFACT=$(find release -name "*.dmg" -type f 2>/dev/null | head -1 || true)
              fi
              # Fallback to ZIP if DMG not found
              if [ -z "$ARTIFACT" ]; then
                ARTIFACT=$(find release -name "ACCELARA*.zip" -type f 2>/dev/null | head -1 || true)
              fi
              if [ -z "$ARTIFACT" ]; then
                ARTIFACT=$(find release -name "*.zip" -type f 2>/dev/null | head -1 || true)
              fi
              
              # Find app bundle
              APP_BUNDLE=$(find release -name "ACCELARA.app" -type d 2>/dev/null | head -1 || true)
              if [ -z "$APP_BUNDLE" ]; then
                APP_BUNDLE=$(find release -name "*.app" -type d 2>/dev/null | head -1 || true)
              fi
              
              # If still not found, try architecture-specific directories
              if [ -z "$ARTIFACT" ] && [ "${{ matrix.goarch }}" == "arm64" ]; then
                ARTIFACT=$(find release/mac-arm64 -name "*.dmg" -type f 2>/dev/null | head -1 || true)
                if [ -z "$APP_BUNDLE" ]; then
                  APP_BUNDLE=$(find release/mac-arm64 -name "*.app" -type d 2>/dev/null | head -1 || true)
                fi
              fi
              if [ -z "$ARTIFACT" ] && [ "${{ matrix.goarch }}" == "amd64" ]; then
                ARTIFACT=$(find release/mac -name "*.dmg" -type f 2>/dev/null | head -1 || true)
                if [ -z "$APP_BUNDLE" ]; then
                  APP_BUNDLE=$(find release/mac -name "*.app" -type d 2>/dev/null | head -1 || true)
                fi
              fi
            fi
            echo "artifact=$ARTIFACT" >> $GITHUB_OUTPUT
            echo "app_bundle=$APP_BUNDLE" >> $GITHUB_OUTPUT
          elif [ "${{ matrix.platform }}" == "win" ]; then
            if [ -d "release" ]; then
              # Look for NSIS installer first
              ARTIFACT=$(find release -name "ACCELARA-Installer-*.exe" -type f 2>/dev/null | head -1 || true)
              if [ -z "$ARTIFACT" ]; then
                ARTIFACT=$(find release -name "ACCELARA*.exe" -type f 2>/dev/null | head -1 || true)
              fi
              if [ -z "$ARTIFACT" ]; then
                ARTIFACT=$(find release -name "*.exe" -type f 2>/dev/null | head -1 || true)
              fi
            fi
            echo "artifact=$ARTIFACT" >> $GITHUB_OUTPUT
            echo "app_bundle=" >> $GITHUB_OUTPUT
          else
            if [ -d "release" ]; then
              # Look for AppImage - try multiple patterns
              # electron-builder might create ACCELARA.AppImage or ACCELARA-1.0.0.AppImage
              ARTIFACT=$(find release -name "ACCELARA*.AppImage" -type f 2>/dev/null | head -1 || true)
              if [ -z "$ARTIFACT" ]; then
                # Try without ACCELARA prefix
                ARTIFACT=$(find release -name "*.AppImage" -type f 2>/dev/null | head -1 || true)
              fi
              if [ -z "$ARTIFACT" ]; then
                # Try in subdirectories
                ARTIFACT=$(find release -type f -name "*.AppImage" 2>/dev/null | head -1 || true)
              fi
            fi
            echo "artifact=$ARTIFACT" >> $GITHUB_OUTPUT
            echo "app_bundle=" >> $GITHUB_OUTPUT
          fi
          
          if [ -n "$ARTIFACT" ]; then
          echo "Found artifact: $ARTIFACT"
            ls -lh "$ARTIFACT" || true
          else
            echo "Warning: No artifact found"
            echo "Searching in release directory:"
            find release -type f -name "*.dmg" -o -name "*.zip" -o -name "*.exe" -o -name "*.AppImage" 2>/dev/null | head -10 || true
          fi
          
          if [ -n "$APP_BUNDLE" ]; then
            echo "Found app bundle: $APP_BUNDLE"
          fi
          
          # Don't fail if artifact not found - let the upload step handle it
          exit 0  # Always succeed - upload step will be skipped if no artifact

      - name: Upload Artifact
        if: steps.find-artifacts.outputs.artifact != ''
        uses: actions/upload-artifact@v4
        with:
          name: accelara-${{ matrix.platform }}-${{ matrix.arch }}
          path: ${{ steps.find-artifacts.outputs.artifact }}
          retention-days: 30

  release:
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Determine version
        id: version
        run: |
          VERSION="${GITHUB_REF#refs/tags/}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"

      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Prepare release assets
        shell: bash
        run: |
          mkdir -p release-assets
          
          # Copy all artifacts with proper naming
          for file in artifacts/accelara-*/*; do
            if [ -f "$file" ]; then
              # Extract platform and arch from artifact folder name
              folder=$(basename $(dirname "$file"))
              platform_arch="${folder#accelara-}"
              
              # Get file extension
              ext="${file##*.}"
              
              # Create standardized name: ACCELARA-{platform}-{arch}.{ext}
              newname="ACCELARA-${platform_arch}.${ext}"
              cp "$file" "release-assets/$newname"
              echo "Copied: $(basename "$file") -> $newname"
            fi
          done
          
          # Create checksums
          cd release-assets
          find . -type f -exec sha256sum {} \; > SHA256SUMS.txt
          echo ""
          echo "Release assets:"
          ls -lh

      - name: Publish GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.version.outputs.version }}
          name: Release ${{ steps.version.outputs.version }}
          body: |
            ## ACCELARA ${{ steps.version.outputs.version }}
            
            ### Downloads
            
            **macOS:**
            - Intel (x64): `ACCELARA-mac-x64.dmg`
            - Apple Silicon (arm64): `ACCELARA-mac-arm64.dmg`
            
            **Windows:**
            - `ACCELARA-win-x64.exe`
            
            **Linux:**
            - `ACCELARA-linux-x64.AppImage`
            
            ### Checksums
            
            See `SHA256SUMS.txt` for file integrity verification.
          files: release-assets/*
          draft: false
          prerelease: ${{ contains(steps.version.outputs.version, '-') || contains(steps.version.outputs.version, 'alpha') || contains(steps.version.outputs.version, 'beta') || contains(steps.version.outputs.version, 'rc') }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}