name: Build and Release

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:

jobs:
  build:
    runs-on: ${{ matrix.os }}
    timeout-minutes: 120

    strategy:
      matrix:
        include:
          - os: macos-latest
            platform: mac
            arch: x64
            goos: darwin
            goarch: amd64
            ext: dmg
          - os: macos-latest
            platform: mac
            arch: arm64
            goos: darwin
            goarch: arm64
            ext: dmg
          - os: windows-latest
            platform: win
            arch: x64
            goos: windows
            goarch: amd64
            ext: exe
          - os: ubuntu-latest
            platform: linux
            arch: x64
            goos: linux
            goarch: amd64
            ext: AppImage

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.21'

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: npm

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable

      - name: Install Rust targets for macOS cross-compilation
        if: matrix.platform == 'mac' && matrix.goarch == 'amd64'
        shell: bash
        run: |
          echo "Installing x86_64-apple-darwin target for Intel macOS build..."
          rustup target add x86_64-apple-darwin
          echo "Installed targets:"
          rustup target list --installed

      - name: Cache Rust dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            src-tauri/target/
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Build Go binaries
        timeout-minutes: 10
        shell: bash
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
          CGO_ENABLED: ${{ matrix.goos == 'windows' && '0' || '1' }}
        run: |
          mkdir -p bin
          go build -ldflags="-s -w" -trimpath -o bin/api-wrapper${{ matrix.goos == 'windows' && '.exe' || '' }} ./cmd/api-wrapper
          go build -ldflags="-s -w" -trimpath -o bin/clidm${{ matrix.goos == 'windows' && '.exe' || '' }} ./cmd/clidm
          # Strip binaries on Unix-like systems to further reduce size
          if [ "${{ matrix.goos }}" != "windows" ]; then
            if command -v strip &> /dev/null; then
              echo "Stripping binaries..."
              strip bin/api-wrapper${{ matrix.goos == 'windows' && '.exe' || '' }} 2>/dev/null || echo "strip failed, continuing..."
              strip bin/clidm${{ matrix.goos == 'windows' && '.exe' || '' }} 2>/dev/null || echo "strip failed, continuing..."
              echo "✓ Binaries optimized"
            else
              echo "⚠ strip not available, skipping"
            fi
          fi
          echo "Downloading Iris..."
          bash scripts/download-iris.sh || echo "Warning: Failed to download Iris"
          echo "Binary sizes:"
          ls -lh bin/ || true

      - name: Install Node Deps
        shell: bash
        env:
          PATH: /usr/bin:/bin:/usr/local/bin:${{ env.PATH }}
          SHELL: /bin/bash
        run: |
          export PATH="/usr/bin:/bin:/usr/local/bin:$PATH"
          export SHELL="/bin/bash"
          # Ensure npm can find sh
          npm config set script-shell /bin/sh || echo "Warning: Could not set npm script-shell"
          npm ci

      - name: Build Frontend
        shell: bash
        env:
          PATH: /usr/bin:/bin:/usr/local/bin:${{ env.PATH }}
          SHELL: /bin/bash
        run: |
          export PATH="/usr/bin:/bin:/usr/local/bin:$PATH"
          export SHELL="/bin/bash"
          # Ensure npm can find sh
          npm config set script-shell /bin/sh || echo "Warning: Could not set npm script-shell"
          npm run build:react

      - name: Verify Resources
        shell: bash
        env:
          PATH: /usr/bin:/bin:/usr/local/bin:${{ env.PATH }}
          SHELL: /bin/bash
        run: |
          export PATH="/usr/bin:/bin:/usr/local/bin:$PATH"
          export SHELL="/bin/bash"
          # Ensure npm can find sh
          npm config set script-shell /bin/sh || echo "Warning: Could not set npm script-shell"
          npm run verify:resources

      - name: Install jq (for JSON manipulation)
        shell: bash
        run: |
          # Install jq for reliable JSON manipulation
          if ! command -v jq &> /dev/null; then
            if [[ "$RUNNER_OS" == "Linux" ]]; then
              sudo apt-get update -qq && sudo apt-get install -y jq
            elif [[ "$RUNNER_OS" == "macOS" ]]; then
              brew install jq || echo "Warning: Could not install jq via brew"
            elif [[ "$RUNNER_OS" == "Windows" ]]; then
              choco install jq -y || echo "Warning: Could not install jq via choco"
            fi
          fi
          # Verify jq is available
          if command -v jq &> /dev/null; then
            echo "✓ jq is available: $(jq --version)"
          else
            echo "⚠ Warning: jq is not available, will use Python fallback"
          fi

      - name: Disable beforeBuildCommand for CI builds
        shell: bash
        run: |
          # Temporarily disable beforeBuildCommand to prevent PATH issues
          # We already built the frontend in previous steps
          if [ -f "src-tauri/tauri.conf.json" ]; then
            # Backup original config
            cp src-tauri/tauri.conf.json src-tauri/tauri.conf.json.bak
            
            # Try using jq first (most reliable for JSON)
            if command -v jq &> /dev/null; then
              jq '.build.beforeBuildCommand = ""' src-tauri/tauri.conf.json > src-tauri/tauri.conf.tmp.json && \
              mv src-tauri/tauri.conf.tmp.json src-tauri/tauri.conf.json && \
              echo "✓ Disabled beforeBuildCommand using jq"
            elif command -v python3 &> /dev/null; then
              # Use Python to properly modify JSON
              python3 -c "import json; f = open('src-tauri/tauri.conf.json', 'r'); config = json.load(f); f.close(); config['build']['beforeBuildCommand'] = ''; f = open('src-tauri/tauri.conf.json', 'w'); json.dump(config, f, indent=2); f.close(); print('✓ Disabled beforeBuildCommand using Python')"
            else
              # Last resort: use sed with a pattern that handles escaped quotes
              # This is tricky because sed doesn't understand JSON escaping
              # We'll match from "beforeBuildCommand": " to the closing " before the comma
              perl -i -pe 's/"beforeBuildCommand": "[^"]*(?:\\.[^"]*)*"/"beforeBuildCommand": ""/' src-tauri/tauri.conf.json 2>/dev/null || \
              sed -i.bak 's/"beforeBuildCommand": "[^"]*"/"beforeBuildCommand": ""/' src-tauri/tauri.conf.json || \
              sed -i '' 's/"beforeBuildCommand": "[^"]*"/"beforeBuildCommand": ""/' src-tauri/tauri.conf.json || \
              echo "✗ ERROR: Could not modify tauri.conf.json"
              
              # Verify JSON is still valid
              if command -v python3 &> /dev/null; then
                python3 -m json.tool src-tauri/tauri.conf.json > /dev/null 2>&1 && \
                echo "✓ JSON is valid after modification" || \
                (echo "✗ ERROR: JSON is invalid after modification!" && cat src-tauri/tauri.conf.json && exit 1)
              fi
            fi
            
            echo "Modified beforeBuildCommand in tauri.conf.json"
          fi

      - name: Install Linux build dependencies
        if: matrix.platform == 'linux'
        shell: bash
        run: |
          # Install GTK/GLib and other system dependencies required for Tauri on Linux
          echo "Installing system dependencies for Tauri Linux build..."
          sudo apt-get update -qq
          sudo apt-get install -y \
            libwebkit2gtk-4.1-dev \
            build-essential \
            curl \
            wget \
            file \
            libssl-dev \
            libgtk-3-dev \
            libayatana-appindicator3-dev \
            librsvg2-dev \
            libjavascriptcoregtk-4.1-dev \
            pkg-config \
            squashfs-tools || echo "⚠ Some packages may have failed to install"
          
          # Verify critical packages
          pkg-config --exists glib-2.0 && echo "✓ glib-2.0 found" || echo "✗ glib-2.0 not found"
          pkg-config --exists gobject-2.0 && echo "✓ gobject-2.0 found" || echo "✗ gobject-2.0 not found"
          pkg-config --exists gtk+-3.0 && echo "✓ gtk+-3.0 found" || echo "✗ gtk+-3.0 not found"
      
      - name: Verify build prerequisites
        if: matrix.platform == 'linux'
        shell: bash
        run: |
          echo "=== Verifying Linux build prerequisites ==="
          echo "Checking for icon file:"
          if [ ! -f "build/icon.png" ]; then
            echo "Warning: icon.png not found, attempting to create from icon.icns"
            # Try to convert from icns if available
            if command -v convert &> /dev/null; then
              # Linux: use ImageMagick to convert
              convert build/icon.icns build/icon.png 2>/dev/null && echo "✓ Converted icon.icns to icon.png" || echo "⚠ Conversion failed - electron-builder will use default icon"
            else
              echo "⚠ ImageMagick not available - installing for icon conversion"
              sudo apt-get update -qq && sudo apt-get install -y imagemagick 2>/dev/null || echo "⚠ Could not install ImageMagick"
              if command -v convert &> /dev/null; then
                convert build/icon.icns build/icon.png 2>/dev/null && echo "✓ Converted icon.icns to icon.png" || echo "⚠ Conversion failed"
              else
                echo "⚠ No conversion tool available, electron-builder will use default icon"
              fi
            fi
          else
            echo "✓ icon.png found"
            ls -la build/icon.png
          fi
          echo ""
          echo "Checking for Go binaries:"
          if [ -f "bin/api-wrapper" ] && [ -f "bin/clidm" ]; then
            echo "✓ Go binaries found"
            ls -lh bin/api-wrapper bin/clidm
            chmod +x bin/api-wrapper bin/clidm || true
          else
            echo "✗ ERROR: Go binaries not found!"
            ls -la bin/ || echo "bin/ directory does not exist"
            exit 1
          fi
          echo ""
          echo "Checking for dist directory:"
          if [ -d "dist" ]; then
            echo "✓ dist directory found"
            ls -la dist/ | head -5
          else
            echo "✗ ERROR: dist directory not found!"
            exit 1
          fi

      - name: Build Tauri App (macOS)
        if: matrix.platform == 'mac'
        timeout-minutes: 90
        shell: bash
        env:
          PATH: /usr/bin:/bin:/usr/local/bin:${{ env.PATH }}:$HOME/.cargo/bin
          SHELL: /bin/bash
        run: |
            set +e  # Don't exit on error immediately - we'll handle errors explicitly
            echo "=== Building Tauri app ==="
            export PATH="/usr/bin:/bin:/usr/local/bin:$HOME/.cargo/bin:$PATH"
            export SHELL="/bin/bash"
            
            # Ensure npm can find sh
            npm config set script-shell /bin/sh || echo "Warning: Could not set npm script-shell"
            
            # Verify make and npm are available
            which make || echo "Warning: make not found"
            which npm || echo "Warning: npm not found"
            which uname || echo "Warning: uname not found"
            
            # Determine target directory based on architecture
            if [ "${{ matrix.goarch }}" == "amd64" ]; then
              TARGET_DIR="x86_64-apple-darwin"
            else
              TARGET_DIR="aarch64-apple-darwin"
            fi
            
            # Build Tauri app (Tauri handles DMG creation automatically)
            # beforeBuildCommand is already disabled in previous step
            echo "Building Tauri app for target: $TARGET_DIR"
            if [ "${{ matrix.goarch }}" == "amd64" ]; then
              npx tauri build --bundles dmg --target x86_64-apple-darwin 2>&1 | tee build.log || { echo "Build failed. Last 50 lines of log:"; tail -50 build.log 2>/dev/null || cat build.log 2>/dev/null || echo "No log file found"; exit 1; }
            else
              npx tauri build --bundles dmg --target aarch64-apple-darwin 2>&1 | tee build.log || { echo "Build failed. Last 50 lines of log:"; tail -50 build.log 2>/dev/null || cat build.log 2>/dev/null || echo "No log file found"; exit 1; }
            fi
            
            # Find the DMG file - check target-specific directory first (for cross-compilation)
            echo "Searching for DMG file..."
            
            # Check target-specific directory first (cross-compilation output location)
            DMG_PATH=$(find "src-tauri/target/$TARGET_DIR/release/bundle/dmg" -name "*.dmg" 2>/dev/null | head -1)
            
            # Fallback to generic release directory (native builds)
            if [ -z "$DMG_PATH" ]; then
              echo "DMG not found in target-specific directory, checking generic release directory..."
              DMG_PATH=$(find src-tauri/target/release/bundle/dmg -name "*.dmg" 2>/dev/null | head -1)
            fi
            
            # Final fallback: search entire target directory
            if [ -z "$DMG_PATH" ]; then
              echo "DMG not found in expected locations, searching entire target directory..."
              DMG_PATH=$(find src-tauri/target -name "*.dmg" -type f 2>/dev/null | head -1)
            fi
            
            echo "Found DMG at: $DMG_PATH"
            
            if [ -z "$DMG_PATH" ]; then
              echo "✗ ERROR: DMG file not found!"
              echo "Searching in bundle directory:"
              find src-tauri/target/release/bundle -type f 2>/dev/null || echo "No files found in bundle"
              echo "Searching in entire target directory:"
              find src-tauri/target -name "*.dmg" -type f 2>/dev/null || echo "No DMG files found in target"
              echo "Listing target/release structure:"
              ls -la src-tauri/target/release/ 2>/dev/null || echo "target/release not found"
              echo "Listing target/release/bundle structure:"
              ls -la src-tauri/target/release/bundle/ 2>/dev/null || echo "target/release/bundle not found"
              echo "Last 100 lines of build log:"
              tail -100 build.log 2>/dev/null || echo "No build log available"
              exit 1
            fi
            
            echo "✓ DMG created: $DMG_PATH"
            ls -lh "$DMG_PATH"
            
            # Remove quarantine attributes and ad-hoc code sign the app bundle
            # This prevents "damaged and can't be opened" errors
            if [ -n "$APP_BUNDLE" ]; then
              echo "=== Removing quarantine and code signing app bundle ==="
              
              # Remove quarantine attribute (if present)
              xattr -cr "$APP_BUNDLE" 2>/dev/null || echo "Warning: Could not remove quarantine attributes"
              
              # Ad-hoc code sign the app bundle (doesn't require a certificate)
              # This makes Gatekeeper happier even without a developer certificate
              codesign --force --deep --sign - "$APP_BUNDLE" 2>/dev/null || echo "Warning: Could not code sign app bundle"
              
              # Verify the signature
              codesign --verify --verbose "$APP_BUNDLE" 2>/dev/null || echo "Warning: Code signature verification failed"
              
              echo "✓ App bundle prepared (quarantine removed, ad-hoc signed)"
            fi
            
            # Recreate DMG with the fixed app bundle
            echo "=== Recreating DMG with fixed app bundle ==="
            if [ -n "$APP_BUNDLE" ]; then
              # Create a temporary directory for DMG contents
              TEMP_DMG_DIR=$(mktemp -d)
              cp -R "$APP_BUNDLE" "$TEMP_DMG_DIR/"
              
              # Create Applications symlink
              ln -s /Applications "$TEMP_DMG_DIR/Applications"
              
              # Remove old DMG
              rm -f "$DMG_PATH"
              
              # Create new DMG with proper formatting
              hdiutil create -volname "ACCELARA" -srcfolder "$TEMP_DMG_DIR" -ov -format UDZO "$DMG_PATH" 2>&1 || {
                echo "Warning: Failed to recreate DMG, using original"
              }
              
              # Clean up
              rm -rf "$TEMP_DMG_DIR"
              
              echo "✓ DMG recreated with fixed app bundle"
            fi
            
            # Copy to release directory with architecture naming
            mkdir -p release
            ARCH_DMG="release/ACCELARA-mac-${{ matrix.goarch }}.dmg"
            cp "$DMG_PATH" "$ARCH_DMG"
            echo "✓ Copied to: $ARCH_DMG"
            ls -lh "$ARCH_DMG"
            
            # Verify binaries in app bundle - check target-specific directory first
            APP_BUNDLE=$(find "src-tauri/target/$TARGET_DIR/release/bundle/macos" -name "*.app" -type d 2>/dev/null | head -1)
            # Fallback to generic release directory
            if [ -z "$APP_BUNDLE" ]; then
              APP_BUNDLE=$(find src-tauri/target/release/bundle/macos -name "*.app" -type d 2>/dev/null | head -1)
            fi
            if [ -n "$APP_BUNDLE" ]; then
              echo "=== Verifying binaries in app bundle ==="
              echo "App bundle found at: $APP_BUNDLE"
              BIN_PATH="$APP_BUNDLE/Contents/Resources/bin"
              if [ -d "$BIN_PATH" ]; then
                echo "✓ Bin directory found: $BIN_PATH"
                ls -lh "$BIN_PATH" || echo "Could not list bin directory"
                if [ -f "$BIN_PATH/api-wrapper" ] && [ -f "$BIN_PATH/iris" ]; then
                  echo "✓ All binaries verified"
                else
                  echo "⚠ Warning: Some binaries missing (Tauri should have bundled them)"
                  echo "Files in bin directory:"
                  ls -la "$BIN_PATH" 2>/dev/null || echo "Could not list bin directory"
                fi
              else
                echo "⚠ Warning: Bin directory not found (Tauri should have created it)"
                echo "Contents of Resources directory:"
                ls -la "$APP_BUNDLE/Contents/Resources" 2>/dev/null || echo "Could not list Resources directory"
              fi
            else
              echo "⚠ Warning: App bundle not found for verification"
            fi
            
            echo "✓ macOS build completed successfully"
            exit 0  # Explicitly exit with success code

      - name: Build Tauri App (Windows)
        if: matrix.platform == 'win'
        timeout-minutes: 90
        shell: bash
        env:
          PATH: /usr/bin:/bin:/usr/local/bin:${{ env.PATH }}:$HOME/.cargo/bin
          SHELL: /bin/bash
        run: |
          echo "=== Building Windows installer ==="
          export PATH="/usr/bin:/bin:/usr/local/bin:$HOME/.cargo/bin:$PATH"
          export SHELL="/bin/bash"
          # Ensure npm can find sh
          npm config set script-shell /bin/sh || echo "Warning: Could not set npm script-shell"
          # beforeBuildCommand is already disabled in previous step
          npx tauri build --bundles msi --target x86_64-pc-windows-msvc > build.log 2>&1 || { /bin/cat build.log 2>/dev/null || /usr/bin/cat build.log 2>/dev/null || echo "Build failed. Log file:"; [ -f build.log ] && while IFS= read -r line; do echo "$line"; done < build.log || true; exit 1; }
          echo ""
          echo "=== Windows build output ==="
          if [ -d "src-tauri/target/release/bundle" ]; then
            find src-tauri/target/release/bundle -name "*.msi" -o -name "*.exe" -type f 2>/dev/null || echo "No installer files found"
            # Copy to release directory
            mkdir -p release
            find src-tauri/target/release/bundle -name "*.msi" -o -name "*.exe" -type f -exec cp {} release/ \;
          fi

      - name: Build Tauri App (Linux)
        if: matrix.platform == 'linux'
        timeout-minutes: 90
        shell: bash
        env:
          PATH: /usr/bin:/bin:/usr/local/bin:${{ env.PATH }}:$HOME/.cargo/bin
          SHELL: /bin/bash
        run: |
          set +e  # Don't exit on error immediately - we'll handle errors explicitly
          export PATH="/usr/bin:/bin:/usr/local/bin:$HOME/.cargo/bin:$PATH"
          export SHELL="/bin/bash"
          echo "=== Building Linux AppImage ==="
          echo "PATH: $PATH"
          echo "SHELL: $SHELL"
          echo "Checking for sh:"
          which sh || echo "sh not found in PATH"
          ls -la /bin/sh /usr/bin/sh 2>/dev/null || echo "sh not found in standard locations"
          if [ -f /bin/sh ]; then
            echo "✓ /bin/sh exists"
            # Try to get version, but don't fail if it doesn't support --version (e.g., dash)
            # Use a simpler check that won't fail - just show what sh points to
            SH_LINK=$(readlink /bin/sh 2>/dev/null || echo "unknown")
            echo "sh points to: $SH_LINK"
          fi
          
          # Verify prerequisites before building
          if [ ! -f "bin/api-wrapper" ]; then
            echo "✗ ERROR: api-wrapper binary not found!"
            exit 1
          fi
          if [ ! -d "dist" ]; then
            echo "✗ ERROR: dist directory not found!"
            exit 1
          fi
          
          # Ensure npm can find sh by setting npm config
          npm config set script-shell /bin/sh || echo "Warning: Could not set npm script-shell"
          
          # Build Tauri app (Tauri handles AppImage creation automatically)
          # beforeBuildCommand is already disabled in previous step
          echo "Building Tauri app for target: x86_64-unknown-linux-gnu"
          npx tauri build --bundles appimage --target x86_64-unknown-linux-gnu 2>&1 | tee build.log || { echo "Build failed. Last 50 lines of log:"; tail -50 build.log 2>/dev/null || cat build.log 2>/dev/null || echo "No log file found"; exit 1; }
          
          # Find the AppImage file - check target-specific directory first
          echo "Searching for AppImage file..."
          TARGET_DIR="x86_64-unknown-linux-gnu"
          
          # Check target-specific directory first (cross-compilation output location)
          APPIMAGE=$(find "src-tauri/target/$TARGET_DIR/release/bundle/appimage" -name "*.AppImage" 2>/dev/null | head -1)
          
          # Fallback to generic release directory (native builds)
          if [ -z "$APPIMAGE" ]; then
            echo "AppImage not found in target-specific directory, checking generic release directory..."
            APPIMAGE=$(find src-tauri/target/release/bundle/appimage -name "*.AppImage" 2>/dev/null | head -1)
          fi
          
          # Final fallback: search entire target directory
          if [ -z "$APPIMAGE" ]; then
            echo "AppImage not found in expected locations, searching entire target directory..."
            APPIMAGE=$(find src-tauri/target -name "*.AppImage" -type f 2>/dev/null | head -1)
          fi
          
          echo "Found AppImage at: $APPIMAGE"
          
          if [ -z "$APPIMAGE" ]; then
            echo "✗ ERROR: AppImage file not found!"
            echo "Searching in bundle directory:"
            find src-tauri/target/release/bundle -type f 2>/dev/null || echo "No files found in bundle"
            echo "Searching in entire target directory:"
            find src-tauri/target -name "*.AppImage" -type f 2>/dev/null || echo "No AppImage files found in target"
            echo "Listing target/release structure:"
            ls -la src-tauri/target/release/ 2>/dev/null || echo "target/release not found"
            echo "Listing target/$TARGET_DIR/release structure:"
            ls -la "src-tauri/target/$TARGET_DIR/release/" 2>/dev/null || echo "target/$TARGET_DIR/release not found"
            echo "Last 100 lines of build log:"
            tail -100 build.log 2>/dev/null || echo "No build log available"
            exit 1
          fi
          
          echo "✓ AppImage created: $APPIMAGE"
          ls -lh "$APPIMAGE"
          
          # Copy to release directory
          mkdir -p release
          cp "$APPIMAGE" release/ACCELARA-linux-x64.AppImage
          echo "✓ Copied to: release/ACCELARA-linux-x64.AppImage"
          ls -lh release/ACCELARA-linux-x64.AppImage
          
          # Make executable
          chmod +x release/ACCELARA-linux-x64.AppImage
          echo "✓ Made AppImage executable"
          
          # Verify binaries in app bundle (if unpacked version exists)
          UNPACKED_DIR=$(find src-tauri/target/release -name "*unpacked" -type d 2>/dev/null | head -1)
          if [ -n "$UNPACKED_DIR" ]; then
            echo "=== Verifying binaries in unpacked directory ==="
            BIN_PATH="$UNPACKED_DIR/resources/bin"
            if [ -d "$BIN_PATH" ]; then
              echo "✓ Bin directory found: $BIN_PATH"
              ls -lh "$BIN_PATH" || echo "Could not list bin directory"
              if [ -f "$BIN_PATH/api-wrapper" ] && [ -f "$BIN_PATH/iris" ]; then
                echo "✓ All binaries verified"
              else
                echo "⚠ Warning: Some binaries missing (Tauri should have bundled them)"
              fi
            fi
          fi
          
          echo "✓ Linux build completed successfully"
      
      - name: List build outputs
        shell: bash
        run: |
          set +e  # Don't exit on error for this diagnostic step
          set +o pipefail  # Don't fail on pipe errors
          echo "=== Build Output Structure ==="
          if [ -d "release" ]; then
            echo "=== All DMG files ==="
            find release -name "*.dmg" -type f 2>/dev/null || echo "No DMG files found"
            echo ""
            echo "=== All APP bundles ==="
            find release -name "*.app" -type d 2>/dev/null || echo "No APP bundles found"
            echo ""
            echo "=== All files in release ==="
            (find release -type f 2>/dev/null | head -30) || echo "No files found"
            echo ""
            echo "=== Release directory structure ==="
            ls -la release/ 2>/dev/null || echo "release/ not found"
            if [ -d "release/mac" ]; then
              echo "=== release/mac contents ==="
              ls -la release/mac/ 2>/dev/null || true
            fi
            if [ -d "release/mac-arm64" ]; then
              echo "=== release/mac-arm64 contents ==="
              ls -la release/mac-arm64/ 2>/dev/null || true
            fi
            if [ -d "release/mac-x64" ]; then
              echo "=== release/mac-x64 contents ==="
              ls -la release/mac-x64/ 2>/dev/null || true
            fi
          else
            echo "release directory does not exist"
          fi
          exit 0  # Always succeed - this is a diagnostic step

      - name: Find build artifacts
        id: find-artifacts
        shell: bash
        run: |
          set +e  # Don't exit on error
          set +o pipefail  # Don't fail on pipe errors
          ARTIFACT=""
          APP_BUNDLE=""
          
          if [ "${{ matrix.platform }}" == "mac" ]; then
            # Try multiple possible locations
            if [ -d "release" ]; then
              # DMG is primary distribution format for macOS
              ARTIFACT=$(find release -name "ACCELARA-mac-${{ matrix.goarch }}.dmg" -type f 2>/dev/null | head -1 || true)
              if [ -z "$ARTIFACT" ]; then
                ARTIFACT=$(find release -name "ACCELARA*.dmg" -type f 2>/dev/null | head -1 || true)
              fi
              if [ -z "$ARTIFACT" ]; then
                ARTIFACT=$(find release -name "*.dmg" -type f 2>/dev/null | head -1 || true)
              fi
              # Fallback to ZIP if DMG not found
              if [ -z "$ARTIFACT" ]; then
                ARTIFACT=$(find release -name "ACCELARA*.zip" -type f 2>/dev/null | head -1 || true)
              fi
              if [ -z "$ARTIFACT" ]; then
                ARTIFACT=$(find release -name "*.zip" -type f 2>/dev/null | head -1 || true)
              fi
              
              # Find app bundle
              APP_BUNDLE=$(find release -name "ACCELARA.app" -type d 2>/dev/null | head -1 || true)
              if [ -z "$APP_BUNDLE" ]; then
                APP_BUNDLE=$(find release -name "*.app" -type d 2>/dev/null | head -1 || true)
              fi
              
              # If still not found, try architecture-specific directories
              if [ -z "$ARTIFACT" ] && [ "${{ matrix.goarch }}" == "arm64" ]; then
                ARTIFACT=$(find release/mac-arm64 -name "*.dmg" -type f 2>/dev/null | head -1 || true)
                if [ -z "$APP_BUNDLE" ]; then
                  APP_BUNDLE=$(find release/mac-arm64 -name "*.app" -type d 2>/dev/null | head -1 || true)
                fi
              fi
              if [ -z "$ARTIFACT" ] && [ "${{ matrix.goarch }}" == "amd64" ]; then
                ARTIFACT=$(find release/mac -name "*.dmg" -type f 2>/dev/null | head -1 || true)
                if [ -z "$APP_BUNDLE" ]; then
                  APP_BUNDLE=$(find release/mac -name "*.app" -type d 2>/dev/null | head -1 || true)
                fi
              fi
            fi
            echo "artifact=$ARTIFACT" >> $GITHUB_OUTPUT
            echo "app_bundle=$APP_BUNDLE" >> $GITHUB_OUTPUT
          elif [ "${{ matrix.platform }}" == "win" ]; then
            if [ -d "release" ]; then
              # Look for NSIS installer first
              ARTIFACT=$(find release -name "ACCELARA-Installer-*.exe" -type f 2>/dev/null | head -1 || true)
              if [ -z "$ARTIFACT" ]; then
                ARTIFACT=$(find release -name "ACCELARA*.exe" -type f 2>/dev/null | head -1 || true)
              fi
              if [ -z "$ARTIFACT" ]; then
                ARTIFACT=$(find release -name "*.exe" -type f 2>/dev/null | head -1 || true)
              fi
            fi
            echo "artifact=$ARTIFACT" >> $GITHUB_OUTPUT
            echo "app_bundle=" >> $GITHUB_OUTPUT
          else
            if [ -d "release" ]; then
              # Look for AppImage - try multiple patterns
              # electron-builder might create ACCELARA.AppImage or ACCELARA-1.0.0.AppImage
              ARTIFACT=$(find release -name "ACCELARA*.AppImage" -type f 2>/dev/null | head -1 || true)
              if [ -z "$ARTIFACT" ]; then
                # Try without ACCELARA prefix
                ARTIFACT=$(find release -name "*.AppImage" -type f 2>/dev/null | head -1 || true)
              fi
              if [ -z "$ARTIFACT" ]; then
                # Try in subdirectories
                ARTIFACT=$(find release -type f -name "*.AppImage" 2>/dev/null | head -1 || true)
              fi
            fi
            echo "artifact=$ARTIFACT" >> $GITHUB_OUTPUT
            echo "app_bundle=" >> $GITHUB_OUTPUT
          fi
          
          if [ -n "$ARTIFACT" ]; then
          echo "Found artifact: $ARTIFACT"
            ls -lh "$ARTIFACT" || true
          else
            echo "Warning: No artifact found"
            echo "Searching in release directory:"
            find release -type f -name "*.dmg" -o -name "*.zip" -o -name "*.exe" -o -name "*.AppImage" 2>/dev/null | head -10 || true
          fi
          
          if [ -n "$APP_BUNDLE" ]; then
            echo "Found app bundle: $APP_BUNDLE"
          fi
          
          # Don't fail if artifact not found - let the upload step handle it
          exit 0  # Always succeed - upload step will be skipped if no artifact

      - name: Upload Artifact
        if: steps.find-artifacts.outputs.artifact != ''
        uses: actions/upload-artifact@v4
        with:
          name: accelara-${{ matrix.platform }}-${{ matrix.arch }}
          path: ${{ steps.find-artifacts.outputs.artifact }}
          retention-days: 30

  release:
    needs: build
    runs-on: ubuntu-latest
    timeout-minutes: 30
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Determine version
        id: version
        run: |
          VERSION="${GITHUB_REF#refs/tags/}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"

      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Prepare release assets
        shell: bash
        run: |
          mkdir -p release-assets
          
          # Copy all artifacts with proper naming
          for file in artifacts/accelara-*/*; do
            if [ -f "$file" ]; then
              # Extract platform and arch from artifact folder name
              folder=$(basename $(dirname "$file"))
              platform_arch="${folder#accelara-}"
              
              # Get file extension
              ext="${file##*.}"
              
              # Create standardized name: ACCELARA-{platform}-{arch}.{ext}
              newname="ACCELARA-${platform_arch}.${ext}"
              cp "$file" "release-assets/$newname"
              echo "Copied: $(basename "$file") -> $newname"
            fi
          done
          
          # Create checksums
          cd release-assets
          find . -type f -exec sha256sum {} \; > SHA256SUMS.txt
          echo ""
          echo "Release assets:"
          ls -lh

      - name: Publish GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.version.outputs.version }}
          name: Release ${{ steps.version.outputs.version }}
          body: |
            ## ACCELARA ${{ steps.version.outputs.version }}
            
            ### Downloads
            
            **macOS:**
            - Intel (x64): `ACCELARA-mac-x64.dmg`
            - Apple Silicon (arm64): `ACCELARA-mac-arm64.dmg`
            
            **Windows:**
            - `ACCELARA-win-x64.exe`
            
            **Linux:**
            - `ACCELARA-linux-x64.AppImage`
            
            ### Checksums
            
            See `SHA256SUMS.txt` for file integrity verification.
          files: release-assets/*
          draft: false
          prerelease: ${{ contains(steps.version.outputs.version, '-') || contains(steps.version.outputs.version, 'alpha') || contains(steps.version.outputs.version, 'beta') || contains(steps.version.outputs.version, 'rc') }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}